#!/usr/bin/env python
import rospy
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
import cv2
import numpy as np
from yolov5_ros_msgs.msg import BoundingBox, BoundingBoxes
from geometry_msgs.msg import Twist

class ObjectFollower:
    def __init__(self):
        rospy.init_node('object_follower')

        rospy.Subscriber('/camera/depth_raw', Image, self.depth_callback)
        rospy.Subscriber('/BoundingBoxes', BoundingBoxes, self.bounding_boxes_callback)
        self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)
        self.bridge = CvBridge()
        self.depth_image = None
        self.twist = Twist()
        self.x, self.y, self.z = None, None, None

        self.distance_threshold = 2
        self.stop_threshold = 0.45

        self.approaching_flag = False
        self.finished_flag = False

        self.last_error = 0
        self.error = 0

    def depth_callback(self, data):
        try:
            depth_image = self.bridge.imgmsg_to_cv2(data, "32FC1")
            self.depth_image = np.pad(depth_image, ((80, 0), (0, 0)), mode='constant', constant_values=NAN)
        except CvBridgeError as e:
            rospy.logerr(e)

    def bounding_boxes_callback(self, data):
        rospy.loginfo('t')
        selected_box = max(data.bounding_boxes, key=lambda box: box.probability)
        center_x = (selected_box.xmin + selected_box.xmax) / 2
        center_y = (selected_box.ymin + selected_box.ymax) / 2
        
        if self.depth_image is not None:
            depth = self.depth_image[int(center_y)][int(center_x)]
            rospy.loginfo('depth')
            self.x, self.y, self.z = center_x, center_y, depth

            if self.z < self.stop_threshold:
                rospy.loginfo("Target reached!")
                self.finished_flag = True   
                self.twist.linear.x = 0
                self.twist.angular.z = 0
                self.cmd_vel_pub.publish(self.twist)
                self.finished_call()

            if self.z < self.distance_threshold and not self.finished_flag:
                self.approaching()

    def approaching(self):
        rospy.loginfo("Approaching the target...")
        target_x = self.x
        target_y = self.y 
        c_x = self.depth_image.shape[1] // 2 
        c_y = self.depth_image.shape[0] // 2 
        # error_x = target_x - self.x
        # error_y = target_y - self.y
        self.error = c_x - target_x
        d_error = self.error - self.last_error
        kp, kd = .007, 0
        self.twist.linear.x = 0.35  # 0.18
        if erro != 0:
            self.twist.angular.z = float(erro)*kp + float(d_erro)*kd
            rospy.loginfo("{}, {}".format(erro, self.twist.angular.z))
        else:
            self.twist.angular.z = 0
        self.last_error = self.error
        self.cmd_vel_pub.publish(self.twist)

    def finished_call(self):
        rospy.loginfo("Finished!")

if __name__ == '__main__':
    follower = ObjectFollower()
    rospy.spin()